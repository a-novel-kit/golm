package models

import (
	"encoding/json"
	"fmt"
	"strings"
)

type AssistantMessage struct {
	// An optional name for the participant. Provides the model information to differentiate between participants of
	// the same role.
	Name string
	// The contents of the assistant message. Required unless ToolCalls is specified.
	Content string
	// The tool calls generated by the model, such as function calls.
	ToolCalls []ToolCall
}

func (message AssistantMessage) Message() Message {
	return message
}

func (message AssistantMessage) MarshalJSON() ([]byte, error) {
	messageData := []string{
		`"role":"` + string(MessageRoleAssistant) + `"`,
	}

	if message.Content != "" {
		serializedContent, err := json.Marshal(message.Content)
		if err != nil {
			return nil, fmt.Errorf("AssistantMessage.MarshalJSON: %w", err)
		}

		messageData = append(messageData, `"content":`+string(serializedContent))
	}

	if len(message.ToolCalls) > 0 {
		serializedToolCalls, err := json.Marshal(message.ToolCalls)
		if err != nil {
			return nil, fmt.Errorf("AssistantMessage.MarshalJSON: %w", err)
		}

		messageData = append(messageData, `"tool_calls":`+string(serializedToolCalls))
	}

	if message.Name != "" {
		messageData = append(messageData, `"name":"`+message.Name+`"`)
	}

	return []byte("{" + strings.Join(messageData, ",") + "}"), nil
}

func (message *AssistantMessage) UnmarshalJSON(data []byte) error {
	messageData := struct {
		Name      string      `json:"name"`
		Content   string      `json:"content"`
		ToolCalls []ToolCall  `json:"tool_calls"`
		Role      MessageRole `json:"role"`
	}{}

	if err := json.Unmarshal(data, &messageData); err != nil {
		return fmt.Errorf("AssistantMessage.UnmarshalJSON: %w", err)
	}

	if messageData.Role != MessageRoleAssistant {
		return fmt.Errorf("AssistantMessage.UnmarshalJSON: invalid role %s", messageData.Role)
	}

	message.Name = messageData.Name
	message.Content = messageData.Content

	if messageData.ToolCalls != nil {
		message.ToolCalls = messageData.ToolCalls
	}

	return nil
}
